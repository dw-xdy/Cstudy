#define  _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//int main()
//{
//	int a = 20;
//	int b = -10;
//
//	printf("a = %d, b = %d\n", a, b);
//	return 0;
//}


//判断系统字节序（小端或大端）
//int check_sys()
//{
//	int i = 1;
//	return (*(char*)&i);
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}


//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	return 0;
//}


//int main()
//{
//	char a = -128;
//	printf("%u\n", a);
//	return 0;
//}

//-128的原码：10000000000000000000000010000000
//-128的反码：11111111111111111111111101111111
//-128的补码：11111111111111111111111110000000 ―――― 截断
//截断之后的：10000000  ――――提升之前的补码
//提升的时候的补码是：11111111111111111111111110000000 ――――提升
// （提升的依据是：本身的整型存储的类型，若是char类型符号位：就是“1”，要是unsigned char符号位：就是“0”）


//int main()
//{
//	char a = 128;
//	printf("%u\n", a);
//	return 0;
//}
/* 128的原码：00000000000000000000000010000000，反码和补码都相同，不用管
   截断之后的：10000000
   提升：（原来的是char，有符号：需要补1：11111111111111111111111110000000
   最后看是%u，所以不用管符号：直接输出：11111111111111111111111110000000*/
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));
//	return 0;
//}


//int main()
//{
//	float f = 5.5;
//	//转换为“二进制”，101.1 = 1.001 * 2^2；
//	//此时：s = 0; m = 1.011; e = 2；
//	//0100 0000 1011 0000 0000 0000 0000 0000 
//	// 40 b0 00 00
//	return 0;
//}

//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//    //0 00000000 00000000000000000001001
//    //(-1)^0,  -126, 0.00000000000000000001001
//    //最后的结果是：(-1)^0 * 0.00000000000000000001001 * 2^(-126) 这个数值无限接近于0。
//	printf("n的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);//所以这里输出的结果是：0.000000；
//
//	*pFloat = 9.0;
//	printf("n的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);
//	return 0;
//}







